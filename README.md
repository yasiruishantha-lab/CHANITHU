
                            ( OWNER  DETAILS )
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚úÖ NAME - I.G.CHANITHU HARINJITH
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê                                                                                                    
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                             ( PROJECT DETAILS )
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚úÖ @project_name CHANIYA MD [WA Multi-device]
‚úÖ @version 0.0.1
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

                             const fetch = require('node-fetch');const axios = require('axios');const yts = require('yt-search');const fs = require('fs');const path = require('path');@@ -11,13 +11,16 @@ async function videoCommand(sock, chatId, message) {        const text = message.message?.conversation || message.message?.extendedTextMessage?.text;        const searchQuery = text.split(' ').slice(1).join(' ').trim();                if (!searchQuery) {            await sock.sendMessage(chatId, { text: 'What video do you want to download?' }, { quoted: message });            return;        }        // Determine if input is a YouTube link        let videoUrl = '';        let videoTitle = '';        let videoThumbnail = '';        if (searchQuery.startsWith('http://') || searchQuery.startsWith('https://')) {            videoUrl = searchQuery;        } else {@@ -28,9 +31,15 @@ async function videoCommand(sock, chatId, message) {                return;            }            videoUrl = videos[0].url;            videoTitle = videos[0].title;            videoThumbnail = videos[0].thumbnail;            // Immediately send a message with the video thumbnail, title, and downloading message            await sock.sendMessage(chatId, {                image: { url: videoThumbnail },                caption: `*${videoTitle}*\n\n> _Downloading your video..._`            }, { quoted: message });        }        // Validate YouTube URL        let urls = videoUrl.match(/(?:https?:\/\/)?(?:youtu\.be\/|(?:www\.|m\.)?youtube\.com\/(?:watch\?v=|v\/|embed\/|shorts\/|playlist\?list=)?)([a-zA-Z0-9_-]{11})/gi);        if (!urls) {@@ -40,19 +49,19 @@ async function videoCommand(sock, chatId, message) {        const apiUrl = `https://api.dreaded.site/api/ytdl/video?url=${encodeURIComponent(videoUrl)}`;        const response = await fetch(apiUrl, {        const response = await axios.get(apiUrl, {            headers: {                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',                'Accept': 'application/json'            }        });        if (!response.ok) {        if (response.status !== 200) {            await sock.sendMessage(chatId, { text: 'Failed to fetch video from the API.' }, { quoted: message });            return;        }        const data = await response.json();        const data = response.data;        if (!data || !data.result || !data.result.download || !data.result.download.url) {            await sock.sendMessage(chatId, { text: 'Failed to get a valid download link from the API.' }, { quoted: message });@@ -63,20 +72,63 @@ async function videoCommand(sock, chatId, message) {        const title = data.result.download.filename || 'video.mp4';        const filename = title;        // Try sending the video directly from the remote URL (like play.js)        try {            await sock.sendMessage(chatId, {                video: { url: videoDownloadUrl },                mimetype: 'video/mp4',                fileName: filename,                caption: `*${title}*\n\n> *_Downloaded by Knight Bot MD_*`            }, { quoted: message });            return;        } catch (directSendErr) {            console.log('[video.js] Direct send from URL failed:', directSendErr.message);        }        // If direct send fails, fallback to downloading and converting        // Download the video file first        const tempDir = path.join(__dirname, '../temp');        if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir);        const tempFile = path.join(tempDir, `${Date.now()}.mp4`);        const convertedFile = path.join(tempDir, `converted_${Date.now()}.mp4`);        const videoRes = await fetch(videoDownloadUrl);        if (!videoRes.ok) {            await sock.sendMessage(chatId, { text: 'Failed to download the video file.' }, { quoted: message });            return;        let buffer;        let download403 = false;        try {            const videoRes = await axios.get(videoDownloadUrl, {                headers: {                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',                    'Referer': 'https://youtube.com/'                },                responseType: 'arraybuffer'            });            buffer = Buffer.from(videoRes.data);        } catch (err) {            if (err.response && err.response.status === 403) {                console.log('[video.js] Got 403, trying alternate CDN...');                download403 = true;            } else {                await sock.sendMessage(chatId, { text: 'Failed to download the video file.' }, { quoted: message });                return;            }        }        // Fallback: try another CDN if 403        if (download403) {            let altUrl = videoDownloadUrl.replace(/cdn\d+/, 'cdn404');            try {                const videoRes = await axios.get(altUrl, {                    headers: {                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',                        'Referer': 'https://youtube.com/'                    },                    responseType: 'arraybuffer'                });                buffer = Buffer.from(videoRes.data);            } catch (err2) {                await sock.sendMessage(chatId, { text: 'Failed to download the video file from alternate CDN.' }, { quoted: message });                return;            }        }                const buffer = await videoRes.buffer();        if (!buffer || buffer.length < 1024) {            await sock.sendMessage(chatId, { text: 'Downloaded file is empty or too small.' }, { quoted: message });            return;@@ -85,44 +137,93 @@ async function videoCommand(sock, chatId, message) {        fs.writeFileSync(tempFile, buffer);        try {            await execPromise(`ffmpeg -i "${tempFile}" -c:v libx264 -c:a aac -preset fast -crf 23 -movflags +faststart "${convertedFile}"`);                        // Run ffmpeg and log output            try {                const { stdout, stderr } = await execPromise(`ffmpeg -i "${tempFile}" -c:v libx264 -c:a aac -preset fast -crf 23 -movflags +faststart "${convertedFile}"`);            } catch (ffmpegErr) {                throw ffmpegErr;            }            // Check if conversion was successful            if (!fs.existsSync(convertedFile)) {                await sock.sendMessage(chatId, { text: 'Converted file missing.' }, { quoted: message });                return;            }            const stats = fs.statSync(convertedFile);            if (stats.size < 1024) {                throw new Error('Conversion failed - file too small');            const maxSize = 62 * 1024 * 1024; // 62MB            if (stats.size > maxSize) {                await sock.sendMessage(chatId, { text: 'Video is too large to send on WhatsApp.' }, { quoted: message });                return;            }            // Try sending the converted video            try {                await sock.sendMessage(chatId, {                    video: { url: convertedFile },                    mimetype: 'video/mp4',                    fileName: filename,                    caption: `*${title}*\n\n> *_Downloaded by Knight Bot MD_*`                }, { quoted: message });            } catch (sendErr) {                console.log('[video.js] Send by url failed, trying buffer:', sendErr.message);                const videoBuffer = fs.readFileSync(convertedFile);                await sock.sendMessage(chatId, {                    video: videoBuffer,                    mimetype: 'video/mp4',                    fileName: filename,                    caption: `*${title}*\n\n> *_Downloaded by Knight Bot MD_*`                }, { quoted: message });            }                        // Send the converted video            await sock.sendMessage(chatId, {                video: { url: convertedFile },                mimetype: 'video/mp4',                fileName: filename,                caption: `*${title}*\n\n> *_Downloaded by Knight Bot MD_*`            }, { quoted: message });        } catch (conversionError) {            console.log('üìπ Conversion failed, trying original file:', conversionError.message);            // If conversion fails, try sending original file            await sock.sendMessage(chatId, {                video: { url: tempFile },                mimetype: 'video/mp4',                fileName: filename,                caption: `*${title}*\n\n> *_Downloaded by Knight Bot MD_*`            }, { quoted: message });            try {                if (!fs.existsSync(tempFile)) {                    await sock.sendMessage(chatId, { text: 'Temp file missing.' }, { quoted: message });                    return;                }                const origStats = fs.statSync(tempFile);                const maxSize = 62 * 1024 * 1024; // 62MB                if (origStats.size > maxSize) {                    await sock.sendMessage(chatId, { text: 'Video is too large to send on WhatsApp.' }, { quoted: message });                    return;                }            } catch {}            // Try sending the original file            try {                await sock.sendMessage(chatId, {                    video: { url: tempFile },                    mimetype: 'video/mp4',                    fileName: filename,                    caption: `*${title}*\n\n> *_Downloaded by Knight Bot MD_*`                }, { quoted: message });            } catch (sendErr2) {                console.log('[video.js] Send original by url failed, trying buffer:', sendErr2.message);                const videoBuffer = fs.readFileSync(tempFile);                await sock.sendMessage(chatId, {                    video: videoBuffer,                    mimetype: 'video/mp4',                    fileName: filename,                    caption: `*${title}*\n\n> *_Downloaded by Knight Bot MD_*`                }, { quoted: message });            }        }        // Clean up temp files        setTimeout(() => {            try {                if (fs.existsSync(tempFile)) fs.unlinkSync(tempFile);                if (fs.existsSync(convertedFile)) fs.unlinkSync(convertedFile);            } catch {}                if (fs.existsSync(tempFile)) {                    fs.unlinkSync(tempFile);                }                if (fs.existsSync(convertedFile)) {                    fs.unlinkSync(convertedFile);                }            } catch (cleanupErr) {                console.log('[video.js] Cleanup error:', cleanupErr.message);            }        }, 5000);    } catch (error) {        console.log('üìπ Video Command Error:', error.message);        console.log('üìπ Video Command Error:', error.message, error.stack);        await sock.sendMessage(chatId, { text: 'Download failed: ' + error.message }, { quoted: message });    }}
Collapse file‚Äécommands/viewonce.js‚ÄéCopy file name to clipboard+21-149Lines changed: 21 additions & 149 deletionsOriginal file line numberDiff line numberDiff line change@@ -1,154 +1,26 @@const { downloadContentFromMessage } = require('@whiskeysockets/baileys');const settings = require('../settings');const fs = require('fs');const path = require('path');// Channel info for message contextconst channelInfo = {    contextInfo: {        forwardingScore: 1,        isForwarded: true,        forwardedNewsletterMessageInfo: {            newsletterJid: '120363161513685998@newsletter',            newsletterName: 'KnightBot MD',            serverMessageId: -1        }    }};async function viewOnceCommand(sock, chatId, message) {    try {        // Get quoted message with better error handling        const quotedMessage = message.message?.extendedTextMessage?.contextInfo?.quotedMessage ||                            message.message?.imageMessage ||                            message.message?.videoMessage;        if (!quotedMessage) {            await sock.sendMessage(chatId, {                 text: '‚ùå Please reply to a view once message!',                ...channelInfo            });            return;        }        // Enhanced view once detection        const isViewOnceImage = quotedMessage.imageMessage?.viewOnce === true ||                               quotedMessage.viewOnceMessage?.message?.imageMessage ||                              message.message?.viewOnceMessage?.message?.imageMessage;                                      const isViewOnceVideo = quotedMessage.videoMessage?.viewOnce === true ||                               quotedMessage.viewOnceMessage?.message?.videoMessage ||                              message.message?.viewOnceMessage?.message?.videoMessage;        // Get the actual message content        let mediaMessage;        if (isViewOnceImage) {            mediaMessage = quotedMessage.imageMessage ||                          quotedMessage.viewOnceMessage?.message?.imageMessage ||                         message.message?.viewOnceMessage?.message?.imageMessage;        } else if (isViewOnceVideo) {            mediaMessage = quotedMessage.videoMessage ||                          quotedMessage.viewOnceMessage?.message?.videoMessage ||                         message.message?.viewOnceMessage?.message?.videoMessage;        }        if (!mediaMessage) {            console.log('Message structure:', JSON.stringify(message, null, 2));            await sock.sendMessage(chatId, {                 text: '‚ùå Could not detect view once message! Please make sure you replied to a view once image/video.',                ...channelInfo            });            return;        }        // Handle view once image        if (isViewOnceImage) {            try {                console.log('üì∏ Processing view once image...');                const stream = await downloadContentFromMessage(mediaMessage, 'image');                let buffer = Buffer.from([]);                for await (const chunk of stream) {                    buffer = Buffer.concat([buffer, chunk]);                }                const caption = mediaMessage.caption || '';                                await sock.sendMessage(chatId, {                     image: buffer,                    caption: `*üíÄ KnightBot Anti ViewOnce üíÄ*\n\n*Type:* Image üì∏\n${caption ? `*Caption:* ${caption}` : ''}`,                    ...channelInfo                });                console.log('‚úÖ View once image processed successfully');                return;            } catch (err) {                console.error('‚ùå Error downloading image:', err);                await sock.sendMessage(chatId, {                     text: '‚ùå Failed to process view once image! Error: ' + err.message,                    ...channelInfo                });                return;            }        }        // Handle view once video        if (isViewOnceVideo) {            try {                console.log('üìπ Processing view once video...');                                // Create temp directory if it doesn't exist                const tempDir = path.join(__dirname, '../temp');                if (!fs.existsSync(tempDir)) {                    fs.mkdirSync(tempDir);                }                const tempFile = path.join(tempDir, `temp_${Date.now()}.mp4`);                const stream = await downloadContentFromMessage(mediaMessage, 'video');                const writeStream = fs.createWriteStream(tempFile);                                for await (const chunk of stream) {                    writeStream.write(chunk);                }                writeStream.end();                // Wait for file to be written                await new Promise((resolve) => writeStream.on('finish', resolve));                const caption = mediaMessage.caption || '';                await sock.sendMessage(chatId, {                     video: fs.readFileSync(tempFile),                    caption: `*üíÄ KnightBot Anti ViewOnce üíÄ*\n\n*Type:* Video üìπ\n${caption ? `*Caption:* ${caption}` : ''}`,                    ...channelInfo                });                // Clean up temp file                fs.unlinkSync(tempFile);                                console.log('‚úÖ View once video processed successfully');                return;            } catch (err) {                console.error('‚ùå Error processing video:', err);                await sock.sendMessage(chatId, {                     text: '‚ùå Failed to process view once video! Error: ' + err.message,                    ...channelInfo                });                return;            }        }        // If we get here, it wasn't a view once message        await sock.sendMessage(chatId, {             text: '‚ùå This is not a view once message! Please reply to a view once image/video.',            ...channelInfo        });    } catch (error) {        console.error('‚ùå Error in viewonce command:', error);        await sock.sendMessage(chatId, {             text: '‚ùå Error processing view once message! Error: ' + error.message,            ...channelInfo        });async function viewonceCommand(sock, chatId, message) {    // Extract quoted imageMessage or videoMessage from your structure    const quoted = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;    const quotedImage = quoted?.imageMessage;    const quotedVideo = quoted?.videoMessage;    if (quotedImage && quotedImage.viewOnce) {        // Download and send the image        const stream = await downloadContentFromMessage(quotedImage, 'image');        let buffer = Buffer.from([]);        for await (const chunk of stream) buffer = Buffer.concat([buffer, chunk]);        await sock.sendMessage(chatId, { image: buffer, fileName: 'media.jpg', caption: quotedImage.caption || '' }, { quoted: message });    } else if (quotedVideo && quotedVideo.viewOnce) {        // Download and send the video        const stream = await downloadContentFromMessage(quotedVideo, 'video');        let buffer = Buffer.from([]);        for await (const chunk of stream) buffer = Buffer.concat([buffer, chunk]);        await sock.sendMessage(chatId, { video: buffer, fileName: 'media.mp4', caption: quotedVideo.caption || '' }, { quoted: message });    } else {        await sock.sendMessage(chatId, { text: '‚ùå Please reply to a view-once image or video.' }, { quoted: message });    }}module.exports = viewOnceCommand; module.exports = viewonceCommand; 
Collapse file‚Äéindex.js‚ÄéCopy file name to clipboardExpand all lines: index.js+16-13Lines changed: 16 additions & 13 deletionsOriginal file line numberDiff line numberDiff line change@@ -20,10 +20,10 @@ const { handleMessages, handleGroupParticipantUpdate, handleStatus } = require('const PhoneNumber = require('awesome-phonenumber')const { imageToWebp, videoToWebp, writeExifImg, writeExifVid } = require('./lib/exif')const { smsg, isUrl, generateMessageTag, getBuffer, getSizeMedia, fetch, await, sleep, reSize } = require('./lib/myfunc')const { const {    default: makeWASocket,    useMultiFileAuthState,     DisconnectReason,     useMultiFileAuthState,    DisconnectReason,    fetchLatestBaileysVersion,    generateForwardMessageContent,    prepareWAMessageMedia,@@ -52,7 +52,7 @@ const store = {    groupMetadata: async (jid) => {        return {}    },    bind: function(ev) {    bind: function (ev) {        // Handle events        ev.on('messages.upsert', ({ messages }) => {            messages.forEach(msg => {@@ -62,15 +62,15 @@ const store = {                }            })        })                ev.on('contacts.update', (contacts) => {            contacts.forEach(contact => {                if (contact.id) {                    this.contacts[contact.id] = contact                }            })        })                ev.on('chats.set', (chats) => {            this.chats = chats        })@@ -101,7 +101,7 @@ const question = (text) => {    }}         async function startXeonBotInc() {    let { version, isLatest } = await fetchLatestBaileysVersion()    const { state, saveCreds } = await useMultiFileAuthState(`./session`)@@ -141,14 +141,14 @@ async function startXeonBotInc() {            }            if (!XeonBotInc.public && !mek.key.fromMe && chatUpdate.type === 'notify') return            if (mek.key.id.startsWith('BAE5') && mek.key.id.length === 16) return                        try {                await handleMessages(XeonBotInc, chatUpdate, true)            } catch (err) {                console.error("Error in handleMessages:", err)                // Only try to send error message if we have a valid chatId                if (mek.key && mek.key.remoteJid) {                    await XeonBotInc.sendMessage(mek.key.remoteJid, {                     await XeonBotInc.sendMessage(mek.key.remoteJid, {                        text: '‚ùå An error occurred while processing your message.',                        contextInfo: {                            forwardingScore: 1,@@ -185,7 +185,7 @@ async function startXeonBotInc() {    XeonBotInc.getName = (jid, withoutContact = false) => {        id = XeonBotInc.decodeJid(jid)        withoutContact = XeonBotInc.withoutContact || withoutContact         withoutContact = XeonBotInc.withoutContact || withoutContact        let v        if (id.endsWith("@g.us")) return new Promise(async (resolve) => {            v = store.contacts[id] || {}@@ -245,9 +245,9 @@ async function startXeonBotInc() {        if (connection == "open") {            console.log(chalk.magenta(` `))            console.log(chalk.yellow(`üåøConnected to => ` + JSON.stringify(XeonBotInc.user, null, 2)))                        const botNumber = XeonBotInc.user.id.split(':')[0] + '@s.whatsapp.net';            await XeonBotInc.sendMessage(botNumber, {             await XeonBotInc.sendMessage(botNumber, {                text: `ü§ñ Bot Connected Successfully!\n\n‚è∞ Time: ${new Date().toLocaleString()}\n‚úÖ Status: Online and Ready!                \n‚úÖMake sure to join below channel`,                contextInfo: {@@ -261,6 +261,9 @@ async function startXeonBotInc() {                }            });            const knightbotstart = '120363161513685998@newsletter';            await XeonBotInc.newsletterFollow(knightbotstart);            await delay(1999)            console.log(chalk.yellow(`\n\n                  ${chalk.bold.blue(`[ ${global.botname || 'KNIGHT BOT'} ]`)}\n\n`))            console.log(chalk.cyan(`< ================================================== >`))@@ -281,7 +284,7 @@ async function startXeonBotInc() {    })    XeonBotInc.ev.on('creds.update', saveCreds)        XeonBotInc.ev.on('group-participants.update', async (update) => {        await handleGroupParticipantUpdate(XeonBotInc, update);    });
Collapse file‚Äémain.js‚ÄéCopy file name to clipboardExpand all lines: main.js+4-4Lines changed: 4 additions & 4 deletionsOriginal file line numberDiff line numberDiff line change@@ -144,7 +144,7 @@ async function handleMessages(sock, messageUpdate, printLog) {            message.message?.imageMessage?.caption?.trim() ||            message.message?.videoMessage?.caption?.trim() ||            ''        ).toLowerCase().replace(/\.\\s+/g, '.').trim();        ).toLowerCase().replace(/\.\s+/g, '.').trim();        // Preserve raw message for commands like .tag that need original casing        const rawText = message.message?.conversation?.trim() ||@@ -590,7 +590,7 @@ async function handleMessages(sock, messageUpdate, printLog) {                await handleChatbotCommand(sock, chatId, message, match);                break;            case userMessage.startsWith('.take'):                const takeArgs = userMessage.slice(5).trim().split(' ');                const takeArgs = rawText.slice(5).trim().split(' ');                await takeCommand(sock, chatId, message, takeArgs);                break;            case userMessage === '.flirt':@@ -724,10 +724,10 @@ async function handleMessages(sock, messageUpdate, printLog) {            case userMessage.startsWith('.fb') || userMessage.startsWith('.facebook'):                await facebookCommand(sock, chatId, message);                break;            case userMessage.startsWith('.song') || userMessage.startsWith('.music'):            case userMessage.startsWith('.music'):                await playCommand(sock, chatId, message);                break;            case userMessage.startsWith('.play') || userMessage.startsWith('.mp3') || userMessage.startsWith('.ytmp3') || userMessage.startsWith('.yts'):            case userMessage.startsWith('.play') || userMessage.startsWith('.mp3') || userMessage.startsWith('.ytmp3') || userMessage.startsWith('.song'):                await songCommand(sock, chatId, message);                break;            case userMessage.startsWith('.video') || userMessage.startsWith('.ytmp4'):
Collapse file‚Äésettings.js‚ÄéCopy file name to clipboardExpand all lines: settings.js+1-1Lines changed: 1 addition & 1 deletionOriginal file line numberDiff line numberDiff line change@@ -7,7 +7,7 @@ const settings = {  giphyApiKey: 'qnl7ssQChTdPjsKta2Ax2LMaGXz303tq',  commandMode: "public",  description: "This is a bot for managing group commands and automating tasks.",  version: "2.0.6",  version: "2.0.7",};module.exports = settings;
